# Algorithm

## Array

- 데이터의 논리적 순서와 물리적 순서가 동일
- 원칙적으로 데이터에 대한 접근 시간은 동일
- 데이터의 삽입과 삭제시 추가적인 자료의 이동이 발생

## Linked List

- 단순연결리스트,이중연결리스트,원형연결리스트
- 각 데이터 시퀀스가 순서를 가지고 연결된 순차적 구조
- 동적인 데이터 추가/삭제에 유리하다.
- 각 요소는 Node
- 각 Node에는 key와 다음 노드를 가리키는 포인터인 next가 포함
- 첫 번째 요소는 Head
- 마지막 요소는 Tail

## Stack

- 순서가 보존되는 선형 데이터 구조
- 가장 마지막 요소부터 처리하는 LIFO

## Que

- 가장 먼저 입력된 요소를 처리하는 FIFO
- 멀티 스레딩에서 스레드를 관리

## Heap

- Binary Tree
- 최소힙:부모의 키 값이 자식의 키 값보다 작거나 같다
- - 루트 노드의 키 값이 트리의 최솟값
- 최대힙:부모의 키 값이 자식의 키 값보다 크거나 같다.
- - 루트 노드의 키 값이 트리의 최솟값

## Hash table

- 해시함수를 사용하여 변환한 값을 색인으로 삼아 키와 데이터를 저장하는 자료구조

## Tree

- 그래프가 계층적 구조를 가진 형태
- 최상위 노드를 가지고 있다.
- 상위 노드를 parent node ,하위 노드를 child node라 한다.
- Binary Trees
- Binary Search Tree
- Heap

## Graph

- nodes/vertices사이에 edge가 있는 collection
- directed그래프는 일방통행
- undirected그래프는 양방향
- 소셜미디어 네트워크를 나타내는데사용

### 알고리즘

- 입출력,명확성,유한성,유효성(이론적으로 문제해결이라는 관점에서 반드시 만족하지 않아도 되는 효율성)
- 모든 명령은 컴퓨터에 수행,효율적,단순명료,일정한 단계후 반드시 종료

## 알고리즘 설계기법

- 분할정복
- 동적프로그래밍
- 욕심쟁이,탐욕

메모리양 -> 공간복잡도
수행시간 -> 시간복잡도

시간복잡도 알고리즘 단계의 단위 연산의 수행 횟수의 합

- 입력크기,입력 데이터의 상태가 증가하면 수행시간도 증가
- Bigo
- 빅오메가
- 빅세타
- 재귀함수

## 점근선능

- 입력크기가 무한대로 커짐에 따라 결정되는 성능
- 표기법(BigO,BigOmega,BigSeta)
- 최악의경우,최선의 수행시간
- 빅오함수의 크기관계

## 순환알고리즘

- 점화식으로 표현

- 이진탐색,퀵정렬(최악,최선),합병정렬

## 1)분할정복

- 순한적으로 문제를 푸는 하향식 접근방법
- 원래 문제와 동일 ->입력크기만 작아짐
- 서로 독립적
- 처리단계:분할-정복-결합
- 주어진 문제의 입력을 나눌수 없을떄까지 두개이상의 작은 문제들로 순한분할하고
  분할된 작은 문제들을 각각 해결 후 이들의 해를 결합하여 문제의 해를 구하는 방법
- 분할,정복,결합
- 이진탐색
- 합병정렬
- 퀵정렬
- 선택문제

## 분할정복)이진탐색

- 정렬된 상태의 입력데이터를 절반씩 줄여가면서 원하는 값을 찾는 방법
- 정렬된 데이터에 대해서만 적용가능
- 데이터의 이동이발생

## 분할정복)합병정렬

- 입력크기가 n인 문제를 크기가 n/2인 두개의 작은 문제를 분할하고 분할된 두 작은 문제에 대해서 순한적으로 호출하여 주어진 문제를 해걀하는 것으
- 합병정렬에서 크기가 각각 n인 정렬된 두 부분 배열을 하나의 정렬배열로 합병할떄 걸리는 시간
- 합병함수 Merge- 정렬된 두 부분배열을 하나의 정렬배열로 만드는 함수
- O(n)
- tn= 2t(n/2)+0n
- 같은크기의 두 부분배열을 분할하고 순한 호출하여 정렬
- 정렬된 두 부분배열을 합쳐서 하나의 정렬배열을만듬
- 성능 t(n)= 2T(n/2)+0(n),T(1)= 0(1)->o(nlogn)
- 입력크기 n만큼의 추가적인 저장 장소필요

## 분할정복)선택문제

- n개의 원소가 순서로 저장된 배열 a[0..n-1]에서 i번쨰로 작은 원ㅇ소를 찾는 문제
- /5 나머지 버리고 그룹의 개수 (중간값들의 중간값 이용)
- 최소값찾기 적어도 (n-1)번 비교 o(n)
- 최솟값과 최대값 모두찾기 3n/2 -2번비교 O(n)
- 퀵정렬의 partition이용 최악 O(n2),평균 O(n)
- 중간값들의 중간값 이용 최악 O(n) 평균 O(n)

## 분할정복)퀵정렬

- 피벗이 제자리를 잡도록 하여 정렬하는 방식
- 분할함수 파티션

## 동적프로그램

- 문제의 크기가 작은 소문제에 대한 해를 저장해 놓고 이를 이용 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식 접근방법
- 최적성의 원리->점화식도출->소문제의 해를 테이블에 저장->저장된 해를 이용해서 점차적으로 상위문제의 해를 구함
- 원래의 문제와 동일하지만 입력의 크기만 줄어들음
- 최적화문제(최솟값,최댓값)에 주로사용
- 소문제들은 서로 독립적이지 않고 중복되는 부분이존재
- 최적성의 원리를 반드시 만족해야함
- 피보나치 수열문제
- 연쇄 행렬곱셈문제
- 스트링 편집 거리문제
- 모든 정점간의 최단경로
- 저울문제
- 문제의 특성을 분석하여 최적성의 원리가 성립되는지 확인(주어진 문제에 대해서 최적해를 제고하는 점화식을 도출)

## 동적프로그래밍)피보나치수열

## 동적프로그래밍)연쇄행렬곱셈

## 동적프로그래밍)스트링 편집거리문제

- 점화식
- 최적성의 원리가 만족하는지 확인
- 연산
- 성능

## 동적프로그래밍)플로이드 알고리즘

- 모든 정점간의 최단경로
- 가중방향 그래프에서 모든 조합의 두정점간의 최단경로
- 경유할수 있는 정점의 범위를 1에서|v|까지 하나씩 늘려가면서 최단 경로를 구하는 방법
- 가중차의 합이 음수인 사이클이 존재하지 않음
- 점화식

## 동적프로그래밍)저울문제

- 무게 M인 물체를 n개의 추를 이용하여 양팔 저울로 달수 있는지 확인하는 문제
- 점화식
- 정수가 아니면 동적프로그래밍 방법 적용불가

```
C(4,6)은 M456을 수행하는 데 필요한 최소 곱셈 횟수를 의미한다.
3개의 행렬을 곱하는 경우에는 2가지 순서가 존재하며, 이때 필요한 기본 곱셈의 횟수는 다음과 같이 계산된다.
(d0=5, d1=2, d2=3, d3=4, d4=6, d5=7 d6=8)

▶ (M4M5)M6의 곱셈 횟수 = d345 + d356

▶ M4(M5M6)의 곱셈 횟수 = d456 + d346


따라서 C(4,6)의 값은 min(392, 528)인 392가 된다.

```

## 욕심쟁이 (Greedy Algorithm)

- 각 단계마다 국부적인 최적해를 선택해서 전체적인 최적해를 구함
- 항상 전체적인 최적해를 구한다는 것을 보장하지 못함
- 해를 구하는 일련의 선택단계마다 전후 단계의 선택과는 무관하게 해당 단계에서 가장 최선이라 여겨지는 국부적인 최적해를 선택하는

## 욕심쟁이)동전거스름돈 문

- 단순히 액면가가 가장 큰 동전부터 최대한 사용해서 거스름돈을 만듬
- o(n),동전의 액면가가 일반적인 경우에는 해결불가
- 동전의 액면가가 임의로 주어지는 경우에는 욕심쟁이 불가능

## 욕심쟁이)베낭문제

- 단위 무게당 이익이 가장 큰 물체부터 최대한 베낭에 넣음
- 물체를 쪼개 넣을수 있다
- 베낭에 들어 있는 물체의 이익의 합이 최대가 되도록 물체를 넣는 방법을 찾는 문제

## 욕심쟁이)최소신장트리문제

- 그래프의 모든 정점을 포함한 연결된 트리 중에서 가중치의 합이 가장 작은 트리
- 크루스칼
- 프림

## 욕심쟁이)크루스칼

- 가장 무방향 그래프에 대한 트리중에서 간선의 가중치의 합이 가장 작은 트리
- 무방향 그래프 ,모든정점 연결,무사이클
- 서로 다른 연결성분에 속하는 정점을 있는 최소 가중치의 간선을 선택

## 욕심쟁이 프림

- 가장 무방향 그래프에 대한 트리중에서 간선의 가중치의 합이 가장 작은 트리
- 무방향그래프,모든정점연결,무사이클
- 선택된 정점.가중치가 최소인 선택

## 욕심쟁이)최단경로문제

- 플로이드
- 데이스크라

## 욕심쟁이)플로이드문제

- 모든 정점간의 최단경로
- 동적프로그래밍 방법적용

## 욕심쟁이)데이스크라문제

- 특정한 하나의 정점에서 다른 모든 정점으로의 최단경로
- 욕심쟁이
- 음의 가중치를 갖는 간선이 없다고 가정

## 욕심쟁이)작업스케줄링문제

- 가장 적은 개수의 기계를 사용하여 작업간의 충돌이 발행하지 않도록 모든 작업을 기계에 할당하는 문제
- 작업스케줄링 문제
- 최소기계를 선택해서 충돌없이 모든 작업을 기계에 할당하는 문제
- 시작이 빠른작업먼저
  작업선택문제,
  완료시간이 빠른거부터

## 욕심쟁이)작업선택문제

- 작업이 완료가 빠른거부터
- x[1]부터

## 욕심쟁이)허프만코딩

- 문자의 빈도또는 확률 정보를 이용한 통계적 압축방법
- 텍스트에서 각 문자가 출현하는 빈도수에 따라 다른 길이의 경로를 부여
- 출현 빈도수가 낮은 문자 -긴코드
- 인코딩과정
- 주어진 텍스트에서 각 문자의 출현 빈도수를 계산
- 각 문자의 빈도수를 이용하여 허프만 트리를 생성
- 문자의 출현 빈도수에 따라 다른 길이의 부호를 부여
- 인코딩->각문자의 출현 빈도수 계산
- 허프만 트리를 통해 각 문자의 이진코드 부여
- 성능
- 각 문자의 빈더수를 모르면 텍스트를 두번 읽어야 하므로 속도 저하

## 욕심쟁이)허프만 트리

- 욕심쟁이,전 이진트리
- 빈도수가 가장 작은 두트리를 합치는 과정을 반복
- 허프만 트리는 유일하지 안음
- 메세지는 길이는 동일
- 메세지는다름

## 정렬

- 주어진 데이터를 값의 크기 순서에 따라 재배치 하는것
- 내부정렬:모든 데이터를 주 기억장치에 저장한 후 정렬하는 방식
- 외부정렬:
  비교기반 알고리즘:버블정렬,선택정렬,셸정렬,합병정렬,퀵정렬,힙정렬->키값의 비교횟수 n2,n(longN),
  데이터 분포 기반 알고리즘:계수정렬,기수정렬

## 정렬)버블정렬

- 안정적인 정렬
- 서로 인접한 두 원소를검사하여 정렬하는 알고리즘
- 인접한 2개의 레코드를 비교하여 크기가 순서되로 되어 있지 않으면 서로 교환
- 제자리 정렬 알고리즘

## 정렬 )선택정렬

- 데이터가 가장 작은 값부터 차례대로 선택해서 나열하는 방식
- 언제나 동일한 시간 복잡도 n(o2)
- 제자리 정렬 알고리즘
- 안정적이지 않은 정렬 알고리즘

## 정렬)삽입정렬

- 주어진 데이터를 하나씩 뽑은 후 나열된 데이터들이 항상 정렬된 형태를 갖도록 뽑은 데이터를 바은 위치에 삽입해서 나열하는 방식
- 첫번쨰 데이터는 무조건 정렬됫다 가정을하고
- 입력이 거의 정렬되 ㄴ 경우 O(n)
- 안정적인 정렬
- 제자리

## 정렬)셸정렬

- 멀리떨어진 데이터와 비교 .교환해서 처리속도 향상
- 데이터가 삽입될 위치에서 멀리 떨어져 있어도 바로 왼쪽이 이웃한 데이터와의 비교를 통해 한번에 한자리씩만 이동 ->제자리 찾는데 느리다
- N2,nlongn

## 정렬)합병정렬

- 최선/최악/평균 수행시간이 모두 O(logn)
- 안정적인
- 평규적인 경우의 시간복잡도가 nlongn인 알고리즘 중에서 안정적인 정렬알고리즘

## 정렬)퀵정렬

- 피벗
- 제자리 정렬 알고리즘
- 안정적이지 않은 정렬 알고리즘
- 분할정복

## 정렬)힙정렬

- 힙자려구저의 장점을 활용한 정렬
- 최대힙
- 완전 이진트리
- 각 노드의 값은 자신의 자식 노드의 크거나 같다
- 힙의장점:임의의 값 삭제와 삽입이 용이
- 1

## 정렬)비교기반 정렬의하한

## 정렬)계수정렬

## 정렬)기수정렬

## 탐색알고리즘

## 탐색알고리즘)순차탐색

- 데이터큰거에는 적합하지안음
- 리스트 형태로 주어진 원소들에 대해서 처음부터 하나씩 차례대로 비교하면서 원하는 값을 가진원소를 찾는 방법
  순차 탐색은 키값의 순서에 관계없이 무순서로 연속해서 저장된 경우에 적합한 탐색 방법이다.
  입력 데이터에 대한 어떠한 처리도 없다는 것은 키값과는 무관하게 단지 데이터가 입력되는 순서로 저장되어 있다는 것을 의미한다.
  한편 이진 탐색은 데이터가 정렬된 형태를 유지하는 경우에만 적용 가능하며, 탐색 트리를 이용하는 경우에는 삽입을 통해 트리를 생성하는 별도의 초기화 과정을 거쳐야 한다.

## 탐색알고리즘)이진탐색

- 초기화 알고리즘
- 정렬된 리스트 형태로 주어진 원소들을 절반씩 줄여가면서 원하는 값을 가진 원소를 찾는 방법
  이진탐색 방법으로 가장 빨리 찾아낼수 있는 데이터 위치는
  이진 탐색 트리의 평균 탐색 시간은 O(logn)이지만, 리프 노드를 제외한 모든 노드의 차수가 1이 되어 경사 트리가 형성되는 최악의 경우에는 O(n)의 시간 복잡도를 갖는다.
- 삭제 알고리즘
- 연결리스트에서는 이진탐색 불간으
- 탐색 loan
- 초기화 long
- On
- 정렬된 리스트에 대해서만 적용가능
- 삽입과 삭제가 빈번한 경우네는 부적합

## 탐색알고리즘)이진탐색트리

- 이진트리
- 각 노드의 서브트리에 있는 모든 키값은 그 노드의 키값보다 작다
- 각 노드의 오른쪽 서브트리에 모든 키갑ㄱ은 그 노드의 키값보다 크다
- 연결리스트 사용
- 탐색 알고리즘
- 루트 노드로 부터 시작해서 크기 관계에 따라 트리의 경로를 다라 내려가면서 탐색을 수행
- 평균 logn 최악 on
- 삽입 삭제 연산시 기존 노드의 이동이 거의 발생하지 않음
- 원소의 삽입/삭제에 따라 경사 트리 형태가 될수 있음
- 최악의 수행시간

## 탐색알고리즘)흑적트리

- 모든 노드는 흑색이거나 적색이다
- 루트 노드와 리프노드는 흑색이다
- 적색 노드의 부모 노드는 흑색이다
- 임의의 노드로부터 리프 노드까지의 경로상에는 동일한 개수의 흑색 노드가 존재한다

## 탐색알고리즘)B-트리

## 탐색알고리즘)해싱

## 근사알고리즘

- 최적화 문제에 대해서 최적해에 가까운 해를 구하는 다항 시간 알고리즘

## 튜링기계

- 컴퓨터의 이론적 몯레
- 구성요소 ->테이프,기호,헤드,상태,규칙
- 결정론적 튜링기계
- 비결정로적 튜링기계
- 다항 시간 알고리즘
- 나닝도에 따른 문제분류
- - 쉬운문제
- - 어려운문제
    클레스 p와 클래스 NP

## 근사알고리즘)NP-완전문제

안전문제
NP-하드문제
NP\_완전문제와 NP-하드문제

## 근사알고리즘)근사알고리즘

## 허프만 트리

# 공부순서

### 0.문자열

### 1.liked list

- single linked list
- 이중연결

### 2.hash table

### 3.stack

### 4.queue

### 5.재귀

### 6.이진탐색

### 7.tree

### 8.그래프
