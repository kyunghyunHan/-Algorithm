# 과제

# 1.다음은 입력크기 n에대한 빅오 함수들이다.알고리즘 성능관점에서 가장 나쁜것부터 차례대로 나열하시오(7개)

1.O(2^n)
2.O(n^3)
3.O(n^2)
4.O(N log N)
5.O(N)
6.O(log N)
7.O(1)

# 2.다음 4가지의 경우에 해당하는 점화식과 폐쇄형을 쓰시오

1.이진탐색 2.퀵정렬의 최악의 경우 3.합병정렬 4.퀵정렬의 최선의 경우

1.T(n) = T(n/2) + O(1) (n>1), T(1)=1 =>T(n) = O(logn)
2.T(n) = T(n-1) + T(0) + Θ(n) (n>0), T(0)=0 =>T(n) = O(n)

## - 이진탐색

- T(n) = T(n/2) + O(1) (n>1), T(1)=1
- T(n) = O(logn)

## - 퀵정렬의 최악의 경우

- 피벗만 제자리를 잡고
  나머지 모든 원소가 하나의 부분배열이 되는 경우
- T(n) = T(n-1) + T(0) + Θ(n) (n>0),
- O(n2),

## - 합병정렬

- T(n) = 2T(n/2) + Θ(n),n>=2
- T(n)= O(nlogn)

## - 퀵정렬의 최선의 경우

- 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우
- T(n)=2T(n/2)+Θ(n), T(1)=Θ(1)
- T(n)=O(nlogn)

## 3.대표적인 알고리즘 설계 기법이 적용된 문제들을 모두 나열하고 해당 문재의 정의 개념에 대해서 간단히 설명하시오

## 4.주어진 배열에 대해서 퀵정렬의 분할함수 Partition()을 한번 적용한 후의 결과 배열을 구하시오

- a[]= {30 35 25 55 10 50 15 45 20 40}

- 20, 35, 25, 55, 10, 50, 15, 45, 30, 40

```rs
fn partition(a: &mut [usize], n: usize) -> usize {
    let mut left = 1;
    let mut right = n - 1;
    let pivot = a[0]; // 피벗을 a[0]로 설정

    while left <= right {
        while left < n && a[left] <= pivot {
            left += 1;
        }
        println!("{:?}",a);
        while right > 0 && a[right] > pivot {
            right -= 1;
        }
        if left < right {
            a.swap(left, right);
        }
    }
    a.swap(0, right);
    right
}

fn quick_sort(a: &mut [usize], n: usize) {
    if n > 1 {
        let pivot = partition(a, n);
        quick_sort(&mut a[0..pivot], pivot);
        quick_sort(&mut a[pivot + 1..n], n - pivot - 1);
    }
}

pub fn main() {
    let mut a = [30, 35, 25, 55, 10, 50, 15, 45, 20 ,40];
    let n = 10;
    quick_sort(&mut a, n);
    println!("{:?}", a);
}

```

## 5.물체를 쪼갤수 있는 배당문제에 대해수 욕심쟁이 방법을 적용해서 최대 이익을 구하시오

- M=10,n=4
  (p1,p2,p3,p4)=(18,20,9,25),
  (w1,w2,w3,w4)=(5,4,3,4)

## 6.다음 그래프에 대한 최소 신장 트리와 해당 트리의 가중치의 합을 구하시오
