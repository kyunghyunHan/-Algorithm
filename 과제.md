# 과제

# 1.다음은 입력크기 n에대한 빅오 함수들이다.알고리즘 성능관점에서 가장 나쁜것부터 차례대로 나열하시오(7개)

1.O(2^n)
2.O(n^3)
3.O(n^2)
4.O(N log N)
5.O(N)
6.O(log N)
7.O(1)

# 2.다음 4가지의 경우에 해당하는 점화식과 폐쇄형을 쓰시오

1.이진탐색 2.퀵정렬의 최악의 경우 3.합병정렬 4.퀵정렬의 최선의 경우

## 2-1) 이진탐색

- T(n) = T(n/2) + O(1) (n>1), T(1)=1
- T(n) = O(logn)

## 2-2) 퀵정렬의 최악의 경우

- 피벗만 제자리를 잡고
  나머지 모든 원소가 하나의 부분배열이 되는 경우
- T(n) = T(n-1) + T(0) + Θ(n) (n>0),
- O(n^2),

## 2-3) 합병정렬

- T(n) = 2T(n/2) + Θ(n),n>=2
- T(n)= O(nlogn)

## 2-4) 퀵정렬의 최선의 경우

- 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우
- T(n)=2T(n/2)+Θ(n), T(1)=Θ(1)
- T(n)=O(nlogn)

## 3.대표적인 알고리즘 설계 기법이 적용된 문제들을 모두 나열하고 해당 문재의 정의 개념에 대해서 간단히 설명하시오

## 3-1)분할정복알고리즘

- 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법
- 분할: 문제를 더이상 분할할 수 없을 때까지 동일한 유형의 여러 하위 문제로 나눈다.
- 정복: 가장 작은 단위의 하위 문제를 해결하여 정복한다.
- 조합: 하위 문제에 대한 결과를 원래 문제에 대한 결과로 조합한다.

- 하향식 접근방법
- 퀵정렬 : 평균적인 상황에서 최고의성능을 나타내는 정렬 알고리즘,피벗을 하나 삼아 그보다 작은 것을 앞으로 뺴내고 그 뒤에 피벗을 옮겨 피벗보다 큰것,작은것으로 나눈뒤 각각 정렬하는 알고리즘
- 합병정렬 :원소의 개수가 1또는 0이 될떄까지 두부분으로 쪼개고 쪼개서 자른순서의 역순으로크기를 비교해 병합해 나가는 알고리즘

## 3-2)동적프로그래밍

- 최적화 이론의 한기술이며,특정범위까지의 값을 구하기 위해 그것과 다른 범위까지 값을 이용하여 효율적으로 값을 구하는 알고리즘 설계 기법
- 분할정복의 방식과 유사
- 연쇄행렬곱셈:주어진 연쇄행렬들의 곱셈을 각 원소의 곱셈 횟수를 최소로 할 수 있는 행렬곱셈의 순서를 찾는 최적화 문제
- 다익스트라 알고리즘:음의 가중치가 없는 그래프의 한 정점 에서 모든 정점까지의 최단거리를 각각 구하는 알고리즘(최단 경로 문제)
- 베낭문제 :견딜 수 있는 무게가 제한된 배낭에 가장 많은 가치의 물건을 넣기. 모든 무게를 정수로 볼 수 있다면, 배낭의 최대 무게 W일 때 O(W)로 구할 수 있다. 그게 아닌 경우라면 NP-hard이므로 근사 알고리즘을 써야 한다

## 3-3)탐욕(욕심쟁이)

- 그리디 알고리즘의 해가 항상 최적의 해가 아니다
- 그리디 알고리즘(욕심쟁이 알고리즘, Greedy Algorithm)이란 "매 선택에서 지금 이 순간 당장 최적인 답을 선택하여 적합한 결과를 도출하자"라는 모토를 가지는 알고리즘 설계 기법
- 다익스트라 알고리즘:음의 가중치가 없는 그래프의 한 정점 에서 모든 정점까지의 최단거리를 각각 구하는 알고리즘(최단 경로 문제)
- 최소신장트리:크루스칼 알고리즘- 간선이 하나도 없는 상태에서 시작해서 가중치가 가장 작은 간선부터 하나씩 사이클을 만들지 않으면 추가시키는 방법
- 동전거스름돈 문제:거스름돈이 있을떄 동전의 개수를 최소로 하여 돌려주는 문제
- 허프만 코드:허프만 알고리즘에 의해 생성된 최적 이진코드를 말한다. 허프만 알고리즘(Huffman's Algorithm)은 허프만 코드에 해당하는 이진트리를 구축하는 그리디 알고리즘
- 베낭문제:견딜 수 있는 무게가 제한된 배낭에 가장 많은 가치의 물건을 넣기 그리디알고리즘

## 4.주어진 배열에 대해서 퀵정렬의 분할함수 Partition()을 한번 적용한 후의 결과 배열을 구하시오

- a[]= {30 35 25 55 10 50 15 45 20 40}

- 결과:[ 30, 20, 25, 55, 10, 50, 15, 45, 35, 40]

```rs
fn partition(a: &mut [usize], n: usize) -> usize {
    let mut left = 1;
    let mut right = n - 1;
    let pivot = a[0]; // 피벗을 a[0]로 설정

    while left <= right {
        while left < n && a[left] <= pivot {
            left += 1;
        }
        println!("{:?}",a);
        while right > 0 && a[right] > pivot {
            right -= 1;
        }
        if left < right {
            a.swap(left, right);
        }
    }
    a.swap(0, right);
    right
}

fn quick_sort(a: &mut [usize], n: usize) {
    if n > 1 {
        let pivot = partition(a, n);
        quick_sort(&mut a[0..pivot], pivot);
        quick_sort(&mut a[pivot + 1..n], n - pivot - 1);
    }
}

pub fn main() {
    let mut a = [30, 35, 25, 55, 10, 50, 15, 45, 20 ,40];
    let n = 10;
    quick_sort(&mut a, n);
    println!("{:?}", a);
}

```

## 5.물체를 쪼갤수 있는 배당문제에 대해수 욕심쟁이 방법을 적용해서 최대 이익을 구하시오

- M=10,n=4
  (p1,p2,p3,p4)=(18,20,9,25),
  (w1,w2,w3,w4)=(5,4,3,4)

- 이익 (p1, p2, p3, p4) = (18, 20, 9, 25)
- 무게 (w1, w2, w3, w4) = (5, 4, 3, 4)
- (18/5, 20/4, 9/3, 25/4) = (3.6, 5, 3, 6.25)
- 단위 무게당 이익을 내림차순으로 정렬
- (6.25,5, 3.6, 3)
  선택된 물체: (20, 25)
  선택된 물체의 무게: (4, 4)
  선택된 물체의 이익: (20, 25)

- 선택된 물체의 무게 합: 4 + 4 = 8
- 선택된 물체의 이익 합: 20 + 25 = 45
- 최대이익 :45

## 6.다음 그래프에 대한 최소 신장 트리와 해당 트리의 가중치의 합을 구하시오

- 최소신장트리
- 가중치의합

- 5개 구해야함
- 최소신장트리:[a,b][b,e][c,e][a,e][a,c][e,d][d,d][d,f][e,f][c,f]
- 정렬
- 1,2,2,3,4,5,6,6,7,8
- 크루스칼 알고리즘 정렬
- 사이클을 형성하지 않으면서 가중치가 작은 간선부터 선택:[a,b][c,e][a,e][a,c][e,d]

```

[a,b] (가중치: 1)
[c,e] (가중치: 2)
[a,e] (가중치: 3)
[a,c] (가중치: 4)
[e,d] (가중치: 5)
```

```
15
```
