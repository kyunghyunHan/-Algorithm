use ndarray;
use ndarray::{array,arr1,arr2 ,arr3,Array1, Array2,Array};

pub fn main(){
    

    /*
    선형대수학에서 벡터는 수를 순서대로 나열한 것이다.
    벡터는 몇가지 중요한 특징을 가집니다.
    벡터의 차원은 벡터가 가진 원소의 수이며,벡터의 방향은 열방향 행방향인지를 나타냅니다.
    차원은 R^N으로 나타내며 R은 실수,N은 차원을 나타냅니다.
    

    x는 4차원 열벡터,y는 2차원 열벡터 ,z는 4차원 행벡터입니다.
    또는 x ∈ R^4로 표현할수 잇습니다.
    
    벡터 v를 일반적으로 소문자 v로 나타내며 선형대수학에서 벡터에 아무런 표시가 없다면 열방향 이라고 가정합니다.
    행벡터는 w^로 씁니다.
    T는 전치연산을 나타내며 전치연산은 열벡터를 행벡터를 변환합니다.

    벡터에 대해 잘 이해하기 위해 파이썬의 Numpy나 Rust의 ndarray를 사용하겟습니다.
    asArray는 방향이 없는 배열입니다.
    행이나 열 벡터가 아니라 1차원 리스트입니다.

    방향은 대괄호로 지정하며 가장 바깥족 대괄호는 모든 숫자를
    하나의 객체로 묶습니다.
    행벡터(rowVec)는 하나의 행이 모든 숫자를 가지지만  열벡터는 하나의 숫자를 가진 행이 여러개가 있습니다.
     */
    let as_list = arr1(&[1, 2, 3]);
    let as_array = arr1(&[1, 2, 3]);
    let row_vec = arr2(&[[1, 3, 3]]);
    let col_vec = arr2(&[[1], [2], [3]]);

    println!("asList:  {:?}", as_list.shape());
    println!("asArray: {:?}", as_array.shape());
    println!("rowVec:  {:?}", row_vec.shape());
    println!("colVec:  {:?}", col_vec.shape());


    /*
    순서대로 나열된 수 목록은 벡터의 대수학적 해석입니다.
    기하학적으로 해석하면 벡터는 특정 길이와 방향(또는 각도)를 가진 직선입니다.
    벡터의 두 점은 꼬리와 머리라고 부릅니다.
    일반적으로 머리는 꼬리와 명확하게 구분하기 위해 화살표가 달려있습니다.
    벡터를 기하학적 좌표가 인코딩된 형태로 볼수도 있지만 벡터와 좌표는 실제로 다릅니다.
    하지만 벡터가 원점에서 시작될때는 일치합니다.이를 기준위치라 부릅니다
    
    
    
     */
    

    /*
    
    벡터의 연산은 단순하고 직관적이며 에상한 방식대로 정확하게 동작할수 있습니다.
    두 벡터의 덧셈과 뺼셈은 서로 대응되는 원소끼리 더하고 뺼수 있습니다.
    벡터는 동일한 차원을 갖는 벡터끼리만 더하고 뺼수 있습니다.
    R^3의 벡터와 R5의 벡터를 더하고 빼는것은 불가능합니다.

     */

     let v = arr1(&[4, 5, 6]);
     let w = arr1(&[10, 20, 30]);
     let u = arr1(&[0, 3, 6, 9]);
 
     let v_plus_w = &v + &w;
     // Uncomment the following line to see the dimension mismatch error
     // let u_plus_w = &u + &w;
     
     println!("vPlusW: {:?}", v_plus_w);
     // Uncomment the following line to see the dimension mismatch error
     // println!("uPlusW: {:?}", u_plus_w);
     

     let v = arr2(&[[4, 5, 6]]);
     let binding = arr2(&[[10, 20, 30]]);
     let w = binding.t();

     // Perform the addition of v and w
     let result = &v + &w;
     println!("{:?}", result);
 
     /*    
     두 벡터를 기하학적으로 더할떄 한 벡터의 꼬리와 다른 벡터의 머리를 연결합니다
     더한 결과 벡터는 첫번쨰 벡터의 꼬리와 두벤쨰 벡터의 머리를 이은 선 입니다.
     이 방식으로 원하는 만큼 벡터를 더할수 있습니다.
     모든 벡터의 꼬리와 머리를 계속 이으면 최종합은 첫번쨰 꼬리에서 마지막 머리까지 이어지는 선이 됩니다.

     뺴는것은 덧셈과 조금다릅니다.
     두 벡터의 꼬리들을 같은 좌표에 둡니다.뺸결과의 벡터는 두번째 벡터의 머리에서 첫번쨰 벡터의 머리로 가는 선입니다.
     벡터 뺼셈은 기하학적으로 매우 중요한 개념입니다.
     직교벡터 분해의 기초이며 이는 곧 선형 최소제곱법의 기초가되고 선형 최고제곱법은  선형대수학의 가장 중요한 응용입니다.
     
      */


      /*
      스칼라-벡터 곱셈 
      선형대수학에서 스칼라는 벡터나 행렬에 포함된 숫자가 아닌 수 자체입니다.
      스칼라는 일반적으로 a또는 그리스어 소문자로 나타냅니다.
      스칼라 벡터 곱은 간단한 편에 속합니다.
      각 벡터 원소에 스칼라를 곱합니다.밑에와 같습니다.
      벡터를 저장하는 변수의 데이터 타입이 스칼라-벡터 곱셈에서는 데이터타입이 중요합니다.    
      */
      let s= 2;
      let a= [3,4,5];
      let b: ndarray::ArrayBase<ndarray::OwnedRepr<i32>, ndarray::Dim<[usize; 1]>>= arr1(&[3,4,5]);
      println!("{:?}",b*s);

      let s= 2;
      let v= arr1(&[3,6]);
      println!("{:?}",s+v);
      
      

  
     
    /*스칼라 벡터 덧셈
     벡터에 스칼라를 더하는 것은 선형대수학에서 불가능합니다.
     벡터와 스칼라는 별도의 수학적 객체이기떄문입니다.
     하지만 프로그래밍에서는 벡터에 스칼라를 더할수 잇으며  스칼라 벡터 곱셈 연산과 유사합니다.
    각 벡터 원소에 스칼라를 더합니다
    
     */
    
    let s= 2;
    let v: ndarray::ArrayBase<ndarray::OwnedRepr<i32>, ndarray::Dim<[usize; 1]>>= arr1(&[3,6]);
    println!("{:?}",&v +s);

  
    /*스칼라 -벡터 곱셈의 기하학적 해석 
    스칼라는 벡터의 방향을 바꾸지않고 크기만 조정합니다.
    스칼라-벡터 곱셉의 결과는 스칼라가 1보다 큰지 0과 1사이인지 정확히 0인지 음수인지에 따라 다릅니다.

    스칼라는 벡터의 방향을 바꾸지 않습니다.하지만 음수일때 벡터 방향이 바뀌엇습니다.
    모순같지만 벡터는 원점을 통과해서 양방향의 무한히 긴 선을 가리킨다는 해석도있습니다.이것을 1차원 부분공간이라 정의합니다.
    그런 의미에서 회전된 벡터는 여전히 동일한 무한한 선을 가리키므로 음의 스칼라가 방향을 바꾼것이 아닙니다.
    이해석은 행렬공간,고유벡터 ,특이벡터에서 중요합니다.
    벡터 덧셈과 스칼라-벡터곱셈을 이용해 벡터의 평균을 구할수 있습니다.벡터의 평균을 구하는 것은 숫자의 평균과 동일합니다.
    벡터의 평군을 구하려면 먼저 두벡터를 더하고 스칼라 1/2를 곱하면 댑니다 일반적으로 N개벡터의 평균을 구하려면 모두 더하고 스칼라1/N을 곱헙니다; 
    
    
    */

    /*전치 
    전치 연산은 열벡터를 행벡터또는 반대로 변환합니다.
    행렬에는 행과 열이 있으므로 각 행렬 원소는 (행,열)인덱스를 가리킵니다.전치연산은 단순히 이러한 인덱스를 맞바꾸는 것입니다.

    벡터는 방향에 따라 하나의 행 또는 하나의 열입니다.예를 들어 6차원 행벡터에서 i인덱스는 1로 고정이고 j는 1에서 6까지 존재합니다.
    6차원 열벡터는 i인덱스가 1에서 6까지 존재하고 j는 1로 고정입니다.따라서 i와 j인덱스를 맞바꾸면 행과 열이 뒤바뀝니다.

    중효한 규칙은 벡터를 두번 전치하면 벡터는 원래 방향이 됩니다.다시말해 vᵀᵀ = v입니다 
    이는  데이터 과학과 머신러닝등 여러 중요한 증명에서 핵심근거가 됩니다.
    예를 들어 데이터 행렬에 자신의 전치를 곱하면 대칭공분산 행렬이 만들어집니다.

    */

    /*벡터 브로드캐스팅 
    브로드 캐스팅 연산은 현대 컴퓨터 기반 선형대수학에서만 존재합니다.
    브로드캐스팅은 본질적으로 한 벡터를 다른 벡터의 각 원소로 연산을 여러번반복하는 작업입니다.

    벡터[1 2 3]의 전치와 [10 20]의 패턴을 모두 모은 다음 덧셈을 브로드캐스팅하면 이식들을 하나의 식으로 간결하게 구현이 가능합니다
    
     */

     let w = arr2(&[[10,20]]);
     let binding = arr2(&[[1,2,3]]);
     let v = binding.t();
     println!("{}",&v+&w)



    /*벡터 크기와 단위벡터 
    벡터의 크기(기하하적 길이 또는 노름)는 벡터의 꼬리부터 머리까지의거리이며  표준 유클리드 거리 공식으로 구합니다
    벡터 크기는 벡터양 옆에 이중 수직 막대로 표시합니다 (|| v ||).
    일부 응용에서는 제곱 코드를 사용하는데 이떄는 오른쪽에 있는 제곱근 항을 제거합니다
    (||v||2)

    수학에서 벡터의 차원은 벡터의 원소 수이고 길이는 기하학적 거리입니다 
    프로그램에서는 len은 배열의 차원을 반환하고 np.norm()은 기하학적 길이를 반환합니다

    여러 응용 분야에서 기하학적인 길이가 1인 벡터를 사용하는데 이를 단위벡터라고합니다
    응용의 예로는 직교행렬과 회전행렬 .고유벡터 특이벡터가 있습니다.
    단위벡터는 ||v|| = 1로 정의합니다

    단위벡터가 아닌 벡터가 많지만 비단위 벡터로 이루어진 무한 집합이 단위벡터의 무한집합보다 아무리크다고 해도 무한 단위벡터의 수와 비단위벡터의 수는 모두 똑같이 무한합니다
    모든 비단위벡터는 하나의 단위벡터와 연관되어 있습니다.
    즉 비단위벡터와 같은 방향의
    */





    /*벡터 내적 */
    /*내적의 분배법칙 */
    /*내적의 기하학적 해석 */
     /*그 외 벡터 곱셈 */
     /*아다마르곱 */
    /*외적 */
     /*교차곱과 삼중곱 */
    /*직교벡터 분해 */
}