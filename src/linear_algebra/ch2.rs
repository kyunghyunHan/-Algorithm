use plotters::prelude::*;
use ndarray::prelude::*;
use rand::Rng;



pub fn main() {

    /* 
    벡터집합
    벡터들의 모음을 집합 이라합니다.
    벡터 집합은 S또는 V와 같이 대문자로 표시합니다.
    벡터집합은 유한 또는 무한한 수의 벡터를 가질수 있습니다.
    무한한 수의 벡터를 가진 벡터집합은 너무 추상적으로 느껴지기도 하지만 벡터 공간이 무한한 집합이고 이는 통계 모델을 데이터에 적합시킬떄 큰 영향을 미칩니다.
    벡터 집합이 비어있다면 V={}로 나타냅니다.
     */

    /*
    선형 가중 결합
    선형 가중결합은 어려 변수마다 가중치를 다르게 주어 정보를 혼합하는 방법입니다.
    이 기초 연산을 선형 혼합 또는 가중 결합 이라고도 합니다.
    선형 가중 결합은 단순하게 스칼라-벡터 곱셈을 한다음 합하는 것입니다.
    벡터 집합에서 각 벡터에 스칼라를 곱한 다음 이들을 더해 하나의 벡터를 만듭니다.

    모든 벡터 vⅈ의 차원은 같다고 가정합니다.λ는 0을 포함한 임의의 실수가 될수 있습니다.
    벡터의 뺄셈 연산을 위해 다시 작성할수 있지만 λⅈ를음수로 두면 뺴는것가 같기때문에 기본적으로 선형가중결합을 합으로 다루는 것이 더 편합니다.

    선형 가중결합은 다음 코드처럼 구현하기 쉽습니다.

    

     */

    let l1 = 1.0;
    let l2= 2.0;
    let l3 = -3.0;

    let v1 = arr1(&[4.0, 5.0, 1.0]);
    let v2 = arr1(&[-4.0, 0.0, -4.0]);
    let v3 = arr1(&[1.0, 3.0, 2.0]);

    println!("{}",l1*v1+l2*v2+l3*v3);

    /*
    각 벡터와 계수를 별도에 변수에 저장하는 방법은 번거롭고 더 어려운 문제를 풀떄 확장성이 떨어집니다.

    선형 가중결합은 여러 방면에서 응용됩니다.
    - 통계모델로부터 예측된 데이터는 최소제곱 알고리즘을 통해 계산되는 회귀변수(독립변수)와 계수(스칼라)의 선형 가중 결합으로 생성됩니다.
    - 주성분 분석과 같은 차원 축소 과정에서 각 성분의 성분의 분산을 최대화 하는 가중치와 데이터 채널의 선형가중 결합으로 도출됩니다.
    - 인공 신경망에서는 두가지 연산,즉 입력데이터의 선형가중결합과 비선형 변환이 있습니다. 가중치는 비용 함수를 최소화 하도록 학습됩니다.비용함수는 일반적으로 모델예측과 실제 목표변수사이의 차이입니다.

    선형 가중결합 개념은 부분공간과 행렬공간을 생성하는 메커니즘이며 선형독립성의 핵심입니다.
    
    
     */

    /*
    벡터 집합에서 적어도 하나의 벡터를 집합의 다른 벡터들의 선형가중결합으로 나타낼수 있을 떄 벡터집합을 선형 종속적 이라고합니다.
    반대로 집합에 있는 벡터들의 선형가중 결합으로 집합의 아무런 벡터도 나타낼수 없다면 해당 벡터 집합은 선형 독립적 입니다.

    벡터 집합 V는 선형독립적 입니다.집합의 한 벡터를 집합의 다른 벡터의 선형 배수로 나타낼수 없습니다.집합내의 벡터들을 v₁과 v₂라고 했을떄 v₁= λv₂인 스칼라 λ가 존재하지 않습니다.

    S집합은 선형종속적입니다. 이러한 결합은 무한히 존재하며 그중 두가지는 s₁= .5*s₂와 s₂= 2*s₁입니다.
    
    T는 복잡하지만 결과적으로 선형종속적 집합입니다.( 예로 세번쨰합이 네번쨰 벡터의 두배와 같기떄문)
    데이터과학에서는 선형독립성을 결정하는 방법은 벡터집합으로 행렬을 만들고 행렬의 계수를 계산한 다음 행의 수와 열의 수 중에서 더 작은 값과 비교하는 것입니다.

    이식의 의미는 선형종속적 이라면 집합의 벡터들의 선형가중 결합으로 영벡터를 만들수 있는 것입니다.
    식을 참으로 만드는 λ를 찾을수 있다면 벡터집합은 선형종속적 이며 선형적으로 결합해서 영벡터를 생성할수 있는 방법이 없다면 선형 독립적 입니다.

    식을 0과 같다고 설정하면 접체집합이 종속적 또는 독립적이라는 원리는 강조할수 잇습니다.그렇다면 어떠한 개별 벡터도 종속벡터라는 특권을 가지지 않게 됩니다.독립에 대해 평등한 벡터 집합이 됩니다.

    하지만 선형대수학에서 0과 같은 단순한 해는 좋은 답이 아니기 떄문에 대부분 적어도 하나의 λ ≠ 0이라는 제약 조건을 달게 됩니다.

    0벡터가 포함된 모든 벡터 집합은 당연히 선형 종속적인 집합입니다. 
    0벡터에 스칼라값을 곱하면 여전히 영벡터입니다.따라서 선형 종속정 정의를 항상 만족합니다.

   λ₁ ≠ 0이며 자명하지 않는 해가 존재 한다면 그 집합은 선형 종속성 정의에 부합합니다.


   벡터 집합의 동일한 벡터들을 사용하지만 가중치 숫자를 사용해서 무한히 선형 결합하는 방식으로 벡터 부분공간을 만듭니다.그리고 가능한 모든 선형가중결합을 구성하는 메커니즘을 벡터 집합의 생성 이라고합니다.
    
    이 벡터의 집합의 생성은 집합의 벡터들의 선형결합으로 만들수 있는 무한한 벡터들입니다.
    하나의 벡터만 있는 집합이라면 단순히 그벡터의 가능한 모든 크기의 벡터가 됩니다.
    

    하나의 벡터와 그 벡터가 생성하는 부분공간을 보여줍니다.강조색 점선은 해당 벡터의 모든 크기를 표시합니다.


    R³의 두 벡터를 가진 집합입니다.

    벡터는 R³에 존재하므로 3차원 축에 그래픽으로 나타낼수 있습니다.그러나 생성되는 부분공간은 3차원 공간에서 2차원 평면입니다.
    두벡터를 0으로 크기 조절하면 영벡터가 되기 떄문에 이 평면은 원점을 통과하게됩니다.

    첫번째 예에서는 하나의 벡터가 있고 생성은 1차원 부분공간이었으며 두번쨰 예에서는 두개의 벡터가 있고 생성은 2차원 부분공간이었습니다.


    R³에 두개의 벡터가 존재하지만 이벡터들이 생성하는 부분공간은 여전히 1차원,즉 선입니다.집합의 한 벡터가 이미 다른벡터의 생성안에 존재하기 떄문에 생성측면에서 두벡터중 하나는 중복입니다.

    벡터 집합에서 생성되는 부분 공간의 차원은 선형독립 집합을 형성하는데 필요한 최소한의 벡터 수입니다.벡터 집합이 선형독립적이면 해당 집합의 벡터들로 생성된 부분공간의 차원은 집합의 벡터수와 동일합니다.
    반대로 종속적이라면 해당 벡터들로 생성된 부분공간의 차원은 반드시 해당 집합의 벡터 수보다 작습니다.

    벡터 부분공간의 공식적인 정의는 덧셈과 스칼라 곱셈으로 닫혀있는 부분집합으로 공간의 원점을 포함합니다.
    즉 부분공간에 존재하는 벡터들의 선형가중결합또한 동일한 부분공간에 반드시 존재합니다.
    0벡터도 마찬가지입니다.
     */

    /*기저는 행렬의 정보를 설명하는데 사용하는 자의 집합입니다. 가장일반적인 기저집합은 데카르트 좌표계입니다.
    데카르트 좌표계는 초등학교 때부터 사용한 XY평면입니다. 2차원과 3차원 데카르트 그래프의 기저집합

    데카르트 기저집합은 서로 직교하며 단위길이인 벡터로 이루어져 있습니다.이는 엄청난 특성으로 데카르트 기준집합이 어느곳에서든 존재하는 이유입니다.

    다음은 R²의 또다른 기저집합입니다.
    기저집합 S₂와 T는 모두 동일한 부분공간을 생성합니다.]
    데이터 점 p와 q를 설명한다고 했을떄 기저S또는 기저T를 사용해서 원점과의 관계 ,즉 좌표로 설명이 가능합니다.
   
    기저S에서 이 두좌표는 p = (3,1)와 q = (-6,2)입니다.선형대수학에서 점은 기저벡터의 선형결합으로 표현됩니다.
    점p는 3s₁+1s₂ 결합이고 점 q는 -6s₁ + 2s₂ 결합입니다.

    이점들을 기저 T로 기술하면 좌표로 p= (1,0)와 q = (0,2)가됩니다.
    기저벡터의 관점에서는 점 p는 1t₁+0t₂ ,점 q 는 0t₁+2t₂가 됩니다 (p= t₁,q=2t₂)
    데이터 점 p와 q는 기저집합에 관계없이 동일하지만 T는 간결하고 직관적입니다.

    기저는 데이터과학과 머신러닝에서 매우 중요합니다.

    두변수를 가진 데이터집합입니다.x=0과 y= 0줄에 해당하는 표준기저집합과 주성분 분석 (PCA,왼쪽),독립성분분석(ICA,오른쪽)을 통해 정의된 기저 집합입니다.



    기저는 단순히 생성과 독립성을 결합한 것입니다.
    벡터집합이 특정 부분공간을 생성하고 독립적인 벡터집합이라면 해당부분공간의 집합입니다.
    보통 측정할수 없는 것은 설명할 방법이 없기때문에 기저가 어떤 부분공간의 기저가 되려면 해당 부분공간을 생성할수 있어야 합니다.
    
    위는 1차원 부분공간밖의 점을 보여줍니다.이 부분공간의 기저벡터는 점r을 측정할수 없습니다.강조색 벡터는 자신이 생성하는 부분공간에 대해서는 당연히 유효한 기저벡터이지만 생성하지 못하는 부분공간에서는 기저벡터가 아닙니다.


    따라서 기저는 자신만 사용해서 공간을 생성합니다.부분공간에 있는 모든벡터는 그 기저를 이용한 고유한 좌표를 가져야 하기떄문에 선형독립이어야만 합니다.

    U는 완벽하게 유효한 벡터집합이지만 기저집합은 아닙니다.
    U에 잇는 세백터 의 선형가중 결합 계수로 될수 있는것은 (3,0,1),(0,1.5,1)등등많이 존재합니다.
    이것이 혼란스럽기 때문에 모든 벡터가 기저집합 내에서 고유한 좌표를 가져야 한다고 결론을 내렸습니다.따라서 고유성을 보장하려면 선형독립적이어야합니다.

    점p는 무한한 수의 기저집합을 사용해서 설명할수 잇습니다.
    따라서 가능한 기저집합의 수가 많기 떄문에 측정값은 고유하지 않습니다.
    그러나 하나의 기저집합내에서 하나의 점은 정확히 하나의 선형가중결합으로 정의됩니다.

     */

    let v1 = arr1(&[3.0, 5.0, 1.0]);
    let v2 = arr1(&[0.0, 2.0, 2.0]);

    let mut rng = rand::thread_rng();
    let xlim = (-4.0, 4.0);

    let mut points = Vec::new();

    for _ in 0..100 {
        let scalar1 = rng.gen_range(xlim.0..xlim.1);
        let scalar2 = rng.gen_range(xlim.0..xlim.1);
        let x = v1[0] * scalar1 + v2[0] * scalar2;
        let y = v1[1] * scalar1 + v2[2] * scalar2;
        let z = v1[2] * scalar1 + v2[2] * scalar2;
        points.push((x, y, z));
    }

    // Create a drawing area
    let root = BitMapBackend::new("ch2.png", (800, 600)).into_drawing_area();
    root.fill(&WHITE).unwrap();
    let mut chart = ChartBuilder::on(&root)
    .x_label_area_size(40)
    .y_label_area_size(40)
    .build_cartesian_2d(-4.0..4.0, -4.0..4.0)
    .unwrap();
   chart
        .configure_mesh()
        .x_desc("Length")
        .y_desc("Weight")
        .draw()
        .unwrap();
    chart
    .draw_series(
        points
            .iter()
            .map(|(x, y, _)| Circle::new((*x, *y), 5, Into::<ShapeStyle>::into(&BLACK).filled())
        )
    )
    .unwrap();


    // Create a drawing area
    let root = BitMapBackend::new("ch2.png", (800, 600)).into_drawing_area();
    root.fill(&WHITE).unwrap();
    let mut chart = ChartBuilder::on(&root)
    .x_label_area_size(40)
    .y_label_area_size(40)
    .build_cartesian_2d(-4.0..4.0, -4.0..4.0)
    .unwrap();
   chart
        .configure_mesh()
        .x_desc("Length")
        .y_desc("Weight")
        .draw()
        .unwrap();
    chart
    .draw_series(
        points
            .iter()
            .map(|(x, y, _)| Circle::new((*x, *y), 5, Into::<ShapeStyle>::into(&BLACK).filled())
        )
    )
    .unwrap();

    
    let root = BitMapBackend::new("3d-env.png", (640, 480)).into_drawing_area();

    root.fill(&WHITE).unwrap();

    let mut chart = ChartBuilder::on(&root)
        .margin(20)
        .caption("Empty 3D Figure", ("sans-serif", 40))
        .build_cartesian_3d(0.0..1.0, 0.0..1.0, 0.0..1.0)
        .unwrap();
    chart.configure_axes().draw().unwrap();
    chart.draw_series(SurfaceSeries::xoz(
        (-25..25).map(|v| v as f64 / 10.0), 
        (-25..25).map(|v| v as f64 / 10.0), 
        |x:f64,z:f64|(x * x + z * z).cos()).style(&BLUE.mix(0.2))
    ).unwrap();

}
